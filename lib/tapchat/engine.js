// Generated by CoffeeScript 1.6.2
(function() {
  var B, BacklogDB, Base64, Buffer, CoffeeScript, Config, Connection, Crypto, DataBuffer, Eco, Engine, Express, Fs, Gzippo, Http, Https, LocalStrategy, Log, Passport, PasswordHash, Path, PushClient, SessionStore, Url, Util, WebSocket, WorkingQueue, compact, count, del, ends, extend, flatten, last, merge, starts, _, _ref;

  Path = require('path');

  Fs = require('fs');

  WorkingQueue = require('capisce').WorkingQueue;

  Http = require('http');

  Https = require('https');

  Passport = require('passport');

  LocalStrategy = require('passport-local').Strategy;

  Express = require('express');

  Url = require('url');

  WebSocket = require('faye-websocket');

  PasswordHash = require('password-hash');

  CoffeeScript = require('coffee-script');

  Util = require('util');

  Crypto = require('crypto');

  _ = require('underscore');

  DataBuffer = require('buffer').Buffer;

  Gzippo = require('gzippo');

  Eco = require('eco');

  Log = require('./log');

  Base64 = require('../base64');

  Config = require('./config');

  B = require('./message_builder');

  Buffer = require('./buffer');

  Connection = require('./connection');

  BacklogDB = require('./backlog_db');

  PushClient = require('./push_client');

  SessionStore = require('./session_store');

  _ref = CoffeeScript.helpers, starts = _ref.starts, ends = _ref.ends, compact = _ref.compact, count = _ref.count, merge = _ref.merge, extend = _ref.extend, flatten = _ref.flatten, del = _ref.del, last = _ref.last;

  Engine = (function() {
    function Engine(config, callback) {
      var _this = this;

      this.connections = [];
      this.clients = [];
      this.password = config.password;
      this.port = config.port;
      if (!PasswordHash.isHashed(this.password)) {
        throw 'No password set!';
      }
      this.pushId = config.push_id;
      this.pushKey = new DataBuffer(config.push_key, 'base64');
      this.pushClient = new PushClient(this);
      this.db = new BacklogDB(this, function() {
        _this.startServer(_this.port, callback);
        return _this.db.selectConnections(function(conns) {
          var connInfo, _i, _len, _results;

          _results = [];
          for (_i = 0, _len = conns.length; _i < _len; _i++) {
            connInfo = conns[_i];
            _results.push(_this.addConnection(connInfo));
          }
          return _results;
        });
      });
    }

    Engine.prototype.startServer = function(port, callback) {
      var _this = this;

      Passport.use(new LocalStrategy(function(username, password, done) {
        if (!PasswordHash.verify(password, _this.password)) {
          return done(null, false, {
            message: 'Invalid password'
          });
        }
        return done(null, {});
      }));
      this.sessions = new SessionStore(Path.join(Config.getDataDirectory(), 'sessions.json'));
      this.app = Express();
      if (Log.level === 'silly') {
        this.app.use(Express.logger());
      }
      this.app.use(Express.cookieParser());
      this.app.use(Express.bodyParser());
      this.app.use(Express.methodOverride());
      this.app.use(Passport.initialize());
      this.app.use(Express["static"](__dirname + '/../../web'));
      this.app.use(Gzippo.compress());
      this.app.set('views', __dirname + '/../../web');
      this.app.engine('eco', function(path, options, fn) {
        return Fs.readFile(path, 'utf8', function(err, str) {
          if (err) {
            return fn(err);
          }
          str = Eco.render(str, options);
          return fn(null, str);
        });
      });
      this.app.get('/', function(req, res) {
        return res.render('index.html.eco', {
          layout: false,
          num_clients: _this.clients.length,
          num_connections: _this.connections.length
        });
      });
      this.app.post('/login', function(req, res) {
        var auth;

        req.body.username = 'ignore';
        auth = Passport.authenticate('local', function(err, user, info) {
          var response, sessionId;

          if (err) {
            return next(err);
          }
          if (!user) {
            response = {
              success: false,
              message: info.message
            };
            res.json(response, 401);
          }
          if (user) {
            sessionId = Crypto.randomBytes(32).toString('hex');
            _this.sessions.set(sessionId, {});
            response = {
              success: true,
              session: sessionId
            };
            return res.json(response);
          }
        });
        return auth(req, res);
      });
      this.app.get('/chat/backlog', function(req, res) {
        var events;

        if (!_this.sessions.get(req.cookies.session)) {
          req.socket.end('HTTP/1.1 401 Unauthorized\r\n\r\n');
          return next();
        }
        events = [];
        return _this.getBacklog((function(event) {
          return events.push(_this.prepareMessage(event));
        }), function() {
          return res.json(events);
        });
      });
      this.web = Https.createServer({
        key: Fs.readFileSync(Config.getCertFile()),
        cert: Fs.readFileSync(Config.getCertFile())
      }, this.app);
      this.web.addListener('upgrade', function(request, socket, head) {
        var res;

        request.method = 'UPGRADE';
        res = new Http.ServerResponse(request);
        return _this.app.handle(request, res, function() {
          var ws;

          _this.inbandBacklog = request.param('inband', false);
          if (_this.sessions.get(request.cookies.session)) {
            ws = new WebSocket(request, socket, head);
            Log.debug('websocket client: connected');
            return _this.addClient(ws);
          } else {
            Log.info('websocket client: unauthorized');
            return request.socket.end('HTTP/1.1 401 Unauthorized\r\n\r\n');
          }
        });
      });
      this.web.on('error', function(e) {
        if (_this.retried === false) {
          _this.retried = true;
          Log.info("IPv6 socket failed (" + e.code + "). Trying IPv4.");
          return _this.web.listen(port, function() {
            if (callback) {
              return callback(_this);
            }
          });
        } else {
          return Log.error("Gave up trying to listen on port " + port + ": " + e.code);
        }
      });
      this.retried = false;
      return this.web.listen(port, '::', function() {
        console.log("\nTapChat ready at https://localhost:" + port + "\n");
        if (callback) {
          return callback(_this);
        }
      });
    };

    Engine.prototype.addClient = function(client) {
      var _this = this;

      client.sendQueue = new WorkingQueue(1);
      this.clients.push(client);
      client.onmessage = function(event) {
        var callback, error, handler, message;

        message = JSON.parse(event.data);
        if (!message._reqid) {
          Log.error('Missing _reqid, ignoring message', event.data);
          return;
        }
        Log.silly('Got message:', event.data);
        callback = function(reply) {
          return _this.send(client, {
            _reqid: message._reqid,
            msg: merge(reply, {
              success: true
            })
          });
        };
        if (handler = _this.messageHandlers[message._method]) {
          try {
            return handler.apply(_this, [client, message, callback]);
          } catch (_error) {
            error = _error;
            Log.error("Error handling message", {
              message: event.data,
              error: error.stack
            });
            return client.close();
          }
        } else {
          return Log.warn("No handler for " + message._method);
        }
      };
      client.onclose = function(event) {
        var index;

        Log.info('websocket client: disconnected', {
          code: event.code,
          reason: event.reason
        });
        index = _this.clients.indexOf(client);
        return _this.clients.splice(index, 1);
      };
      this.send(client, {
        type: 'header',
        version_name: Config.getAppVersion(),
        version_code: Config.getAppVersionCode(),
        idle_interval: 29000,
        push_id: this.pushId,
        push_key: Base64.urlEncode(this.pushKey)
      });
      if (!this.inbandBacklog) {
        return this.send(client, {
          type: 'oob_include',
          url: '/chat/backlog'
        });
      } else {
        return this.sendBacklog(client);
      }
    };

    Engine.prototype.send = function(client, message, cb) {
      var json,
        _this = this;

      message = this.prepareMessage(message);
      json = JSON.stringify(message);
      Log.silly('CLIENT SEND:', json);
      client.sendQueue.perform(function(over) {
        return client.send(json, cb ? cb() : void 0, over());
      });
      return message;
    };

    Engine.prototype.prepareMessage = function(message) {
      var now;

      now = parseInt(Date.now() / 1000);
      if (!message.time) {
        message.time = now;
      }
      if (!message.highlight) {
        message.highlight = false;
      }
      if (!message.eid) {
        message.eid = -1;
      }
      return message;
    };

    Engine.prototype.addConnection = function(options) {
      var _this = this;

      return new Connection(this, options, function(conn) {
        _this.connections.push(conn);
        conn.addListener('event', function(event) {
          return _this.broadcast(event);
        });
        return conn.sendBacklog(null, function() {
          if (conn.autoConnect) {
            return conn.connect();
          }
        });
      });
    };

    Engine.prototype.removeConnection = function(conn, cb) {
      var _this = this;

      return conn["delete"](function() {
        _this.connections.splice(_this.connections.indexOf(conn), 1);
        _this.broadcast(B.connectionDeleted(conn));
        return cb();
      });
    };

    Engine.prototype.findConnection = function(cid) {
      var conn, _i, _len, _ref1;

      _ref1 = this.connections;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        conn = _ref1[_i];
        if (conn.id === cid) {
          return conn;
        }
      }
      return null;
    };

    Engine.prototype.broadcast = function(message, cb) {
      var client, queue, _fn, _i, _len, _ref1,
        _this = this;

      queue = new WorkingQueue(this.clients.length + 1);
      Log.silly('BROADCAST', JSON.stringify(message));
      if (!message.is_backlog) {
        if (message.highlight) {
          queue.perform(function(over) {
            return _this.pushClient.sendPush(message, over);
          });
        }
      }
      _ref1 = this.clients;
      _fn = function(client) {
        return queue.perform(function(over) {
          return _this.send(client, message, over);
        });
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        client = _ref1[_i];
        _fn(client);
      }
      if (cb) {
        queue.whenDone(cb);
      }
      queue.doneAddingJobs();
      return message;
    };

    Engine.prototype.sendBacklog = function(client) {
      var _this = this;

      return this.getBacklog(function(event) {
        return _this.send(client, event);
      });
    };

    Engine.prototype.getBacklog = function(callback, done) {
      var conn, queue, _fn, _i, _len, _ref1,
        _this = this;

      queue = new WorkingQueue(1);
      _ref1 = this.connections;
      _fn = function(conn) {
        return queue.perform(function(over) {
          return conn.getBacklog((function(event) {
            return callback(event);
          }), over);
        });
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        conn = _ref1[_i];
        _fn(conn);
      }
      queue.whenDone(function() {
        callback({
          type: 'backlog_complete'
        });
        if (done) {
          return done();
        }
      });
      return queue.doneAddingJobs();
    };

    Engine.prototype.messageHandlers = {
      heartbeat: function(client, message, callback) {
        var bid, buffer, buffers, cid, connection, eid, queue, seenEids, _fn,
          _this = this;

        this.selectedBid = message.selectedBuffer;
        seenEids = JSON.parse(message.seenEids);
        queue = new WorkingQueue(1);
        for (cid in seenEids) {
          buffers = seenEids[cid];
          connection = this.findConnection(parseInt(cid));
          if (!connection) {
            throw "connection not found: " + cid;
          }
          _fn = function(buffer, eid) {
            return queue.perform(function(over) {
              return buffer.setLastSeenEid(eid, over);
            });
          };
          for (bid in buffers) {
            eid = buffers[bid];
            buffer = connection.findBuffer(parseInt(bid));
            if (!buffer) {
              throw "buffer not found: " + bid;
            }
            _fn(buffer, eid);
          }
        }
        queue.whenDone(function() {
          return _this.db.getAllLastSeenEids(function(updatedSeenEids) {
            return _this.send(client, {
              type: 'heartbeat_echo',
              seenEids: updatedSeenEids
            });
          });
        });
        return queue.doneAddingJobs();
      },
      say: function(client, message, callback) {
        var conn, text, to;

        conn = this.findConnection(message.cid);
        to = message.to;
        text = message.msg;
        if (to === '*') {
          conn.consoleBuffer.addEvent({
            type: 'error',
            msg: 'Commands not yet supported.'
          }, callback);
          return;
        }
        if (text) {
          conn.say(to, text);
          return;
        }
        return conn.getOrCreateBuffer(to, 'conversation', function(buffer, created) {
          return callback({
            name: to,
            cid: conn.id,
            type: 'open_buffer',
            _reqid: message._reqid
          });
        });
      },
      join: function(client, message, callback) {
        var chan, conn;

        chan = message.channel;
        conn = this.findConnection(message.cid);
        conn.join(chan);
        return callback({
          name: chan,
          cid: conn.id,
          type: 'open_buffer'
        });
      },
      part: function(client, message, callback) {
        var conn;

        conn = this.findConnection(message.cid);
        conn.part(message.channel);
        return callback();
      },
      disconnect: function(client, message, callback) {
        return this.findConnection(message.cid).disconnect(function() {
          return callback();
        });
      },
      reconnect: function(client, message, callback) {
        var _this = this;

        return this.findConnection(message.cid).reconnect(function() {
          return callback();
        });
      },
      'add-server': function(client, message, callback) {
        var _this = this;

        return this.db.insertConnection(message, function(info) {
          _this.addConnection(info);
          return callback();
        });
      },
      'edit-server': function(client, message, callback) {
        var conn;

        conn = this.findConnection(message.cid);
        return conn.edit(message, callback);
      },
      'delete-connection': function(client, message, callback) {
        var conn;

        conn = this.findConnection(message.cid);
        return this.removeConnection(conn, callback);
      },
      'archive-buffer': function(client, message, callback) {
        var buffer, conn;

        conn = this.findConnection(message.cid);
        buffer = conn.findBuffer(message.id);
        return buffer.archive(callback);
      },
      'unarchive-buffer': function(client, message, callback) {
        var buffer, conn;

        conn = this.findConnection(message.cid);
        buffer = conn.findBuffer(message.id);
        return buffer.unarchive(callback);
      },
      'delete-buffer': function(client, message, callback) {
        var buffer, conn;

        conn = this.findConnection(message.cid);
        buffer = conn.findBuffer(message.id);
        return buffer["delete"](callback);
      },
      'accept-cert': function(client, message, callback) {
        var conn;

        conn = this.findConnection(message.cid);
        return conn.acceptCert(message.fingerprint, message.accept, callback);
      }
    };

    return Engine;

  })();

  module.exports = Engine;

}).call(this);
